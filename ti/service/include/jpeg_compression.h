#ifndef JPEG_COMPRESSION_H
#define JPEG_COMPRESSION_H

// ============================================================================
// Common header files (Standard C)
// ============================================================================
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

// ============================================================================
// C7x-specific headers
// ============================================================================
#ifdef __C7000__
    #include <stdio.h>
    #include <string.h>
    #include <assert.h>
    #include <stdint.h>
    #include <TI/tivx.h>
    #include <utils/ipc/include/app_ipc.h>
    #include <utils/remote_service/include/app_remote_service.h>
    #include <utils/console_io/include/app_log.h>
    #include <utils/mem/include/app_mem.h>
    #include <c7x.h>
#else
// ========================================================================
// A72 (ARM) TYPES COMPATIBILITY
// ========================================================================
    typedef uint8_t uchar64;
#endif

#define JPEG_COMPRESSION_REMOTE_SERVICE_NAME "org.etfbl.jpegcomp"

// ============================================================================
// COMMONS STRUCTURES (USED IN HOST-DEVICE COMMUNICATION)
// ============================================================================

#define PI_VAL 3.14159265358979323846f

/*
* Structure definitions. These are used when passing data via IPC.
*/

typedef struct
{
    int32_t width;                          // image dimensions
    int32_t height;
    
    uint64_t phys_addr_r;                   // R planar
    uint64_t phys_addr_g;                   // G planar
    uint64_t phys_addr_b;                   // B planar
    uint64_t phys_addr_intermediate_1;      // a buffer to write intermediate results on C7x side (we perform allocation on host/A72 side)
    uint64_t phys_addr_intermediate_2;
    uint64_t phys_addr_intermediate_3;    
    uint64_t phys_addr_dct_buff;
    uint64_t phys_addr_y_out;               // return value
    uint32_t output_size;
} JPEG_COMPRESSION_DTO;

#ifdef DEBUG_CYCLE_COUNT
    extern uint64_t timer1;
    extern uint64_t timer2;
    extern uint64_t timer3;
    extern uint64_t start;
#endif


// ============================================================================
// C7x specific functions
// ============================================================================
#ifdef __C7000__
    #define ASSERT_ALIGNED_64(x) (_nassert(((uint64_t)(x) & 0x3F) == 0))

    extern uint8_t std_lum_qt[64];          // quantization table declaration (defined in quantization_table.c)

    typedef struct {
        uint8_t *buffer;    // Buffer in which we write encoded coefficients
        uint32_t byte_pos;  // Current byte in the buffer
        uint32_t bit_pos;   // Current bit position in the current byte (0-7)
        uint8_t current;    // Current byte being constructed
    } BitWriter;

    /*
    *  Structure representing a Huffman code.
    */
    typedef struct {
        uint16_t code;      // Code itself
        uint8_t len;        // Length of the code in bits
    } HuffmanCode;

    /*
    * Structure representing a Variable Length Integer.
    * Used for encoding non-zero DCT coefficients.
    */
    typedef struct {
        uint16_t bits;      // Bits representing the value
        uint8_t len;        // Length of the bits
    } VLI;                  // VLI - Variable Length Integer


    /* Huffman tables */
    extern const HuffmanCode huff_dc_lum[16];   // DC table
    extern const HuffmanCode huff_ac_lum[256];  // AC table

    /* External DCT matrices generated by the Python sciript */
    extern const float dct_matrix_c[64];
    extern const float dct_matrix_c_T[64];

    // Remote service handler
    int32_t JpegCompression_RemoteServiceHandler(char *service_name, uint32_t cmd,
                                                 void *prm, uint32_t prm_size, uint32_t flags);

    // Service initialization function
    int32_t JpegCompression_Init();

    // Convert RGB color space to Y
    void rgb_to_y(uint8_t *r_ptr, uint8_t *g_ptr, uint8_t *b_ptr, int8_t *y_ptr, int num_pixels);

    void perform_dct_on_block(int8_t * restrict b_start, float * restrict dct_coeffs);

    void image_to_blocks(int8_t *image_buffer, uint32_t width, uint32_t height, uint32_t *out_blocks_w, uint32_t *out_blocks_h, int8_t *out_blocks);

    void quantize_block(float *dct_block, int16_t* out_quantized_block);

    void zigzag_order(const int16_t *input_block, int16_t *output_block);

    void bw_write(BitWriter *bw, uint32_t code, int length);

    void bw_put_byte(BitWriter *bw, uint8_t val);

    VLI get_vli(int16_t value);

    int16_t encode_coefficients(int16_t *dct_block, int16_t prev_dc, BitWriter* bw);



#endif 

#endif 
